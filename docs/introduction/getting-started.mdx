---
title: 'Getting started'
description: Learn how to get started with napi-rs.
---

import { GuideVideo } from './guide-video.jsx'

## Start from `@napi-rs/cli`

> The recommend way.

<GuideVideo />

### Install cli

```bash
yarn global add @napi-rs/cli
```

### Create project

```bash
napi new
```

#### Package name

The name filed in `package.json`.

#### Choose targets you want to support

Platforms you want support to.

#### Enable GitHub actions

Generate GitHub actions config for you.

### Deep dive

Here it is recommended to distribute your package under [npm scope](https://docs.npmjs.com/creating-and-publishing-scoped-public-packages/) because `@napi-rs/cli` by default appends the different platform suffixes to the npm package name as the package name for the different platform binary distribution. Using npm scope will reduce the case of package name was taken.

For example if you want publish package `@cool/core`, with the `macOS x64`, `Windows x64` and `Linux aarch64` supported, `@napi-rs/cli` will create and publish four package for you:

- `@cool/core` includes just `JavaScript` codes, which actually load the native binary from per platforms.
- `@cool/core-darwin-x64` for `macOS x64` platform.
- `@cool/core-win32-x64` for `Windows x64` platform.
- `@cool/core-linux-arm64-gnu` for `Linux aarch64` platform.

In every platform binary package, there are `cpu` and `os` fields in there `package.json`:

```json title=package.json
{
  "name": "@cool/core-darwin-x64",
  "version": "1.0.0",
  "os": ["darwin"],
  "cpu": ["x64"]
}
```

And `@cool/core` using these native packages as `optionalDependencies`:

```json title=package.json
{
  "name": "@cool/core",
  "version": "1.0.0",
  "optionalDependencies": {
    "@cool/core-darwin-x64": "^1.0.0",
    "@cool/core-win32-x64": "^1.0.0",
    "@cool/core-linux-arm64": "^1.0.0"
  }
}
```

And your `index.js` in `@cool/core` will be this:

```js title=index.js
const { loadBinding } = require('@node-rs/helper')

// The first argument is the dir to load native binding file during development.
// The second argument is the package name
// The third argument is the binary name of native binding file.
module.exports = loadBinding(__dirname, '@cool/core', 'core')
```

The `loadBinding` function from `@node-rs/helper` will help you to load the **_right_** binary file wherever you are. And actually the `loadBinding` function handle two cases:

#### Package installed in users `node_modules`

<!-- 为了加载正确二进制文件，`loadBinding` 函数会尝试加载该平台下所有可能的包(在给定系统和 CPU 架构下可能存在多种可能的二进制包)，比如在 `Linux x64` 平台，`loadBinding` 会尝试加载 `@cool/core-linux-x64-gnu` 和 `@cool/core-linux-x64-musl`。 如果用户使用的是 `Ubuntu` `Debian` 等预装 `gnu libc` 的操作系统，则 `@cool/core-linux-x64-gnu` 这个包会被加载进来。而如果用户使用的是 `Alpine` 这种预装 `musl libc` 的操作系统，则 `@cool/core-linux-x64-musl` 会被加载进来。 -->

To load the correct binary, the `loadBinding` function tries to load all possible packages for that platform (there may be multiple possible binary packages for a given system and CPU architecture), for example, on the `Linux x64` platform, `loadBinding` tries to load `@cool/core-linux-x64-gnu` and `@cool/core-linux-x64-musl`. The package `@cool/core-linux-x64-gnu` will be loaded if the user is using an operating system like `Ubuntu` `Debian` with `gnu libc` pre-installed. And if the user is using an operating system like `Alpine` with `musl libc` pre-installed, then `@cool/core-linux-x64-musl` will be loaded.

#### Local development

<!-- `@napi-rs/cli` new 命令生成的项目中，package.json 中的 `build` 命令会将 `Rust` 代码编译出来的二进制动态链接库生成到当前目录下，以方便调试。`loadBinding` 在这种情况下也会尝试从给定目录中(在上面例子的 `index.js` 中是 `__dirname`)加载相应的二进制文件。还是以 `Linux x64` 为例，`loadBinding` 函数会依次尝试加载 `core.linux-x64-gnu.node` 和 `core.linux-x64-musl.node` 文件。 -->

The `build` command in package.json in the project generated by the `@napi-rs/cli` new command will generate the binary dynamic link library compiled from the `Rust` code into the current directory for debugging purposes. `loadBinding` will also try to load the corresponding binary from the given directory (`__dirname` in the `index.js` example above) in this case.Again using `Linux x64` as an example, the `loadBinding` function will try to load the `core.linux-x64-gnu.node` and `core.linux-x64-musl.node` files in turn.

## Start from [GitHub template project](https://github.com/napi-rs/package-template)

![package-template](./package-template.png)

1. Go to [GitHub template project](https://github.com/napi-rs/package-template)
2. **Click Use this template**
3. Clone your project
4. rename all `@napi-rs/package-template` in project to your package name.
5. rename all `package-template` in project to you binary name.
